load(to_poly_solve)$

epsilon: 1e-110$

write_quad(file, name, scriptname, abscissae_generator, weights_generator, max_order, num_endpoints) :=
block([i,N,n_,points,p,w,fd],
fd: openw(file),
printf(fd, "// -*- tab-width: 4; indent-tabs-mode: nil; c-basic-offset: 2 -*-
// vi: set et ts=4 sw=2 sts=2:
//
// WARNING
// This file is automatically generated by ~a! Don't edit by hand!

#ifndef DUNE_INCLUDING_IMPLEMENTATION
#error This is a private header that should not be included directly.
#error Use #include <dune/geometry/quadraturerules.hh> instead.
#endif
#undef DUNE_INCLUDING_IMPLEMENTATION

namespace Dune {

  // for fundamental types
  template<typename ct>
  void ~aQuadratureInitHelper<ct,true>::init(int p,
         std::vector< FieldVector<ct, 1> > & _points,
         std::vector< ct > & _weight,
         int & delivered_order)
  {
    switch(p)
    {
", scriptname, name),


for delivered_order: 0 thru max_order do block([], 
    two_r: delivered_order - num_endpoints + 1,
    if mod(two_r, 2) = 0 then block([],
        printf(fd, "    case ~d :
", delivered_order),
        r: two_r / 2, /* number of abscissae without endpoints */
        num_abscissae: r + num_endpoints, 
        points: makelist(rhs(p), p, bfallroots(abscissae_generator(num_abscissae))),
        weights: makelist(bfloat(weights_generator(num_abscissae, p)), p, points),
        N: length(points), /* number of abscissae including endpoints */
        if not N = num_abscissae then print("number of endpoints does not match: N = ~d, r + e = ~d", N, num_abscissae), 
        S: sort(makelist(n, n, 1, N), lambda([x,y], weights[x] < weights[y])),
        printf(fd,"      delivered_order = ~d;
",delivered_order),
        printf(fd,"      _points.resize(~d);
",N),
        printf(fd,"      _weight.resize(~d);
",N),
        for n_: 1 thru N do block([n],
            n: S[n_],
            p: (points[n]+1)/2,
            p: max(p-epsilon,-epsilon)+epsilon,
            w: weights[n]/2,
            printf(fd,"      _points[~d] = ~h;
",n_-1, p),
            printf(fd,"      _weight[~d] = ~h;
",n_-1, w)
       ),
        printf(fd,"      break;

")
    ) else printf(fd, "    // order ~d,~d
    case ~d :
", delivered_order, delivered_order+1, delivered_order)
), 

printf(fd,"    default :
      DUNE_THROW(QuadratureOrderOutOfRange, \"Quadrature rule \" << p << \" not supported!\");
    }
  }
"),


printf(fd,"
  // for non-fundamental types: assign numbers as strings
  template<typename ct>
  void ~aQuadratureInitHelper<ct,false>::init(int p,
         std::vector< FieldVector<ct, 1> > & _points,
         std::vector< ct > & _weight,
         int & delivered_order)
  {
    switch(p)
    {
",name),

for delivered_order: 0 thru max_order do block([], 
    two_r: delivered_order - num_endpoints + 1,
    if mod(two_r, 2) = 0 then block([],
        printf(fd, "    case ~d :
", delivered_order),
        r: two_r / 2, /* number of abscissae without endpoints */
        num_abscissae: r + num_endpoints, 
        points: makelist(rhs(p), p, bfallroots(abscissae_generator(num_abscissae))),
        weights: makelist(bfloat(weights_generator(num_abscissae, p)), p, points),
        N: length(points), /* number of abscissae including endpoints */
        if not N = num_abscissae then print("number of endpoints does not match: N = ~d, r + e = ~d", N, num_abscissae), 
        S: sort(makelist(n, n, 1, N), lambda([x,y], weights[x] < weights[y])),
        printf(fd,"      delivered_order = ~d;
",delivered_order),
        printf(fd,"      _points.resize(~d);
",N),
        printf(fd,"      _weight.resize(~d);
",N),
        for n_: 1 thru N do block([n],
            n: S[n_],
            p: (points[n]+1)/2,
            p: max(p-epsilon,-epsilon)+epsilon,
            w: weights[n]/2,
            printf(fd,"      _points[~d] = ct(\"~h\");
",n_-1, p),
            printf(fd,"      _weight[~d] = ct(\"~h\");
",n_-1, w)
       ),
        printf(fd,"      break;

")
    ) else printf(fd, "    // order ~d,~d
    case ~d :
", delivered_order, delivered_order+1, delivered_order)
), 

printf(fd,"    default :
      DUNE_THROW(QuadratureOrderOutOfRange, \"Quadrature rule \" << p << \" not supported!\");
    }
  }
"), 

printf(fd,"
} // namespace
"),
close(fd)
)$
